#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <poll.h>

#include "common.h"

#define PORT "33401"
#define MAXDATASIZE 100

/* tmp struct for handler threads */
struct handlerinfo {
  int sfd;
};

// get sockaddr, IPv4 or IPv6
void *get_in_addr(struct sockaddr *sa) {
  if (sa->sa_family == AF_INET) {
    return &(((struct sockaddr_in *)sa)->sin_addr);
  }

  return &(((struct sockaddr_in6 *)sa)->sin6_addr);
}

void getinput(char *dest, size_t *res, size_t len) {
  for (int i = 0; i < len; i++) {
    int c = getchar();
    if (c == '\n') {
      *res = i + 1;
      break;
    } 
    dest[i] = c;
  }
  dest[*res - 1] = '\0';
}

#define MAX_RECV_LEN 100
void *thread_recv(void *sfdp) {
  printf("debug\n");
  int sfd = *((int *) sfdp);
  char buff[MAX_RECV_LEN];
  while (1) {
    if (recv(sfd, buff, MAX_RECV_LEN, 0) == -1) {
      perror("recv");
      break;
    }
    if (strcmp(buff, "exit") == 0) {
      printf("Connection ended.\n");
      break;
    }
    printf("%s\n", buff);
    *buff = '\0';
  }
  return NULL; // XXX: make more useful ret value
}

#define MAX_SEND_LEN 100
void *thread_send(void *sfdp) {
  int sfd = *((int *) sfdp);
  char buff[MAX_SEND_LEN];
  size_t msglen;
  int s;

  struct pollfd listener;
  listener.fd = 0;
  listener.events = POLLIN;

  while (1) {
    /* Prompt and wait for input */
    printf(":");
    poll(&listener, 1, -1);

    /* Grab input, check for exit */
    getinput(buff, &msglen, MAX_SEND_LEN);
    if (strcmp(buff, "exit") == 0) {
      printf("Exiting.\n");
      break;
    }

    /* Send the message */
    if ((s = send(sfd, buff, msglen, 0)) != msglen) {
      if (s < 0) {
        perror("send");
        break;
      } else {
        perror("incomplete send");
        break;
      }
    }
  }

  return NULL; // XXX make more useful return type
}

void *connection_handler(void *arg) {
  struct handlerinfo *info = arg;
  pthread_t sender, receiver;

  if (pthread_create(&sender, NULL, thread_send, &info->sfd)) {
    fprintf(stderr, "Could not create message sending thread\n");
    perror("pthread_create");
    return NULL;
  }
  if (pthread_create(&receiver, NULL, thread_recv, &info->sfd)) {
    fprintf(stderr, "Could not create message receiving thread\n");
    perror("pthread_create"); // XXX kill sender thread here
    return NULL;
  }

  pthread_join(sender, NULL);
  pthread_join(receiver, NULL);

  return NULL; // XXX change to more useful return type
}

int main(int argc, char **argv) {
  int sockfd;
  struct addrinfo hints, *servinfo, *p;
  int rv;
  char s[INET6_ADDRSTRLEN];

  if (argc != 2) {
    fprintf(stderr, "usage: client [HOSTNAME]\n");
    exit(1);
  }

  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  if ((rv = getaddrinfo(argv[1], PORT, &hints, &servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    return 1;
  }

  // loop through all the results and connect to the first we can
  for (p = servinfo; p != NULL; p = p->ai_next) {
    if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      perror("client: socket");
      continue;
    }

    if (connect(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
      close(sockfd);
      perror("client: connect");
      continue;
    }

    break;
  }

  if (p == NULL) {
    fprintf(stderr, "client: failed to connect\n");
    return 2;
  }

  inet_ntop(p->ai_family, get_in_addr((struct sockaddr *) p->ai_addr), s, sizeof s);
  printf("connecting to %s\n", s);

  freeaddrinfo(servinfo); // all done with this structure 

  pthread_t handler;
  struct handlerinfo info;
  info.sfd = sockfd;
  if (pthread_create(&handler, NULL, connection_handler, &info)) {
    fprintf(stderr, "Could not create handler for connection\n");
    perror("perror_create");
    exit(EXIT_FAILURE);
  }

  /* Join handler with main on termination, then exit */
  pthread_join(handler, NULL);

  close(sockfd);
  return 0;
}
/*
  for (;;) {
    if ((numbytes = recv(sockfd, buf, MAXDATASIZE - 1, 0)) == -1) {
      perror("recv");
      exit(1);
    }
    printf("%s\n", buf);
    printf(": ");
    getinput(buf, &bufflen, MAXDATASIZE);
    if (strcmp(buf, "exit") == 0) {
      break;
    }
    if (send(sockfd, buf, bufflen, 0) != bufflen) {
      printf("partial write to socket\n");
    }
  }
*/
