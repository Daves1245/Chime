#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/wait.h>
#include <signal.h>
#include <pthread.h>
#include <poll.h>

#include "common.h"

#define PORT "33401"
#define BACKLOG 10

#define MAX_BUF_LEN 100

struct handlerinfo {
  int sfd;
};

void sigchld_handler(int s) {
  // waitpid() might overwrite errno, so we save and restore it
  int saved_errno = errno;
  while (waitpid(-1, NULL, WNOHANG) > 0);
  errno = saved_errno;
}

// get sockaddr, IPv4 or IPv6
void *get_in_addr(struct sockaddr *sa) {
  if (sa->sa_family == AF_INET) {
    return &(((struct sockaddr_in *)sa)->sin_addr);
  }

  return &(((struct sockaddr_in6 *)sa)->sin6_addr);
}

void getinput(char *dest, size_t *res, size_t len) {
  register int c;
  for (int i = 0; i < len; i++) {
    c = getchar();
    if (c == '\n') {
      *res = i + 1;
      break;
    }
    dest[i] = c;
  }

  dest[*res - 1] = '\0';
}

#define MAX_RECV_LEN 100
void *thread_recv(void *sfdp) {
  int sfd = *((int *) sfdp);
  char buff[MAX_RECV_LEN];
  while (1) {
    if (recv(sfd, buff, MAX_RECV_LEN, 0) == -1) {
      perror("recv");
      break;
    }
    if (strcmp(buff, "exit") == 0) {
      printf("Connection ended.\n");
      break;
    }
    printf("%s\n", buff);
    *buff = '\0';
  }
  return NULL; // XXX: pthread_exit(retvalue) ? 
}

#define MAX_SEND_LEN 100
void *thread_send(void *sfdp) {
  int sfd = *((int *)sfdp);
  char buff[MAX_SEND_LEN];
  size_t msglen;
  int s;

  struct pollfd listener;
  listener.fd = 0;
  listener.events = POLLIN;

  while (1) {
    /* Prompt and wait for input */
    printf(":");
    poll(&listener, 1, -1); 

    /* Grab input, check for exit */
    getinput(buff, &msglen, MAX_SEND_LEN);
    if (strcmp(buff, "exit") == 0) {
      printf("Exiting.\n");
      break;
    }
    /* Send the message */
    if ((s = send(sfd, buff, msglen, 0)) != msglen) {
      if (s < 0) {
        perror("send");
        break;
      } else {
        perror("incomplete send");
        break;
      }
    }
  }
  return NULL; // XXX
}

void *connection_handler(void *arg) {
  struct handlerinfo *info = arg;
  pthread_t sender, receiver;

  if (pthread_create(&sender, NULL, thread_send, &info->sfd)) {
    perror("pthread_create");
    return NULL;
  }
  if (pthread_create(&receiver, NULL, thread_recv, &info->sfd)) {
    perror("pthread_create");
    // XXX - kill sender thread that was created but will not be used
    return NULL;
  }

  pthread_join(sender, NULL);
  pthread_join(receiver, NULL);
  return NULL;
}

int main(void) {
  int sockfd, new_fd; // listen on sock_fd, new connections on new
  struct addrinfo hints, *servinfo, *p;
  struct sockaddr_storage their_addr; // connect's address
  socklen_t sin_size;
  struct sigaction sa;
  int yes = 1;
  char s[INET6_ADDRSTRLEN];
  int rv;

  memset(&hints, 0, sizeof hints);
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;
  hints.ai_flags = AI_PASSIVE;

  if ((rv = getaddrinfo(NULL, PORT, &hints, &servinfo)) != 0) {
    fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(rv));
    return 1;
  }

  // loop through all the results and bind to the first we can
  for (p = servinfo; p != NULL; p = p->ai_next) {
    if ((sockfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == -1) {
      perror("server: socket");
      continue;
    }

    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(int)) == -1) {
      perror("setsockopt");
      exit(1);
    }

    if (bind(sockfd, p->ai_addr, p->ai_addrlen) == -1) {
      close(sockfd);
      perror("server: bind");
      continue;
    }

    break;
  }

  freeaddrinfo(servinfo); // all done with this structure

  if (p == NULL) {
    fprintf(stderr, "server: failed to bind\n");
    exit(1);
  }

  if (listen(sockfd, BACKLOG) == -1) {
    perror("listen");
    exit(1);
  }

  sa.sa_handler = sigchld_handler; // reap all dead procedures
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_RESTART;
  if (sigaction(SIGCHLD, &sa, NULL) == -1) {
    perror("sigaction");
    exit(1);
  }

  printf("server: waiting for connections...\n");
  while (1) { // main accept() loop
    sin_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *) &their_addr, &sin_size);

    if (new_fd == -1) {
      perror("accept");
      continue;
    }

    inet_ntop(their_addr.ss_family, get_in_addr((struct sockaddr *) &their_addr), s, sizeof s);
    printf("server: got connection from %s\n", s);

    if (!fork()) { // This is the child process
      close(sockfd); // child doesn't need the listener

      printf("creating threads\n");
      pthread_t handler;
      struct handlerinfo info;
      info.sfd = new_fd;
      
      /* Create a handler for the connection to client */
      if (pthread_create(&handler, NULL, connection_handler, &info)) {
        perror("pthread_create");
        return 0;
      }

      /* Wait for handler to terminate: end of connection with client */
      pthread_join(handler, NULL);
      close(new_fd);
      exit(EXIT_SUCCESS); // XXX
    }
  }
  return 0;
}
/*void oahiwhefoiahwef() {
  for (;;) {
    memset(buff, 0, sizeof buff);
    printf(":");
    getinput(buff, &bufflen, MAX_BUF_LEN);
    if ((tmp = send(new_fd, buff, bufflen, 0)) != bufflen) {
      if (tmp < 0) {
        perror("send");
        continue;
      }
      perror("incomplete write");
    }
    memset(buff, 0, sizeof buff);
    if ((recvlen = recv(new_fd, buff, MAX_BUF_LEN, 0)) == -1) {
      perror("recv");
    }
    printf(">%s\n", buff);
  }
}*/
